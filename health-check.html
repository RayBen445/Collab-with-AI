<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Health Check - Collab-with-AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .health-container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        .health-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .health-header h1 {
            font-size: 2rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e1e5e9;
            border-radius: 10px;
            background: #f8f9fa;
        }
        
        .test-section h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .test-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #dee2e6;
        }
        
        .test-item.success {
            border-left-color: #28a745;
        }
        
        .test-item.warning {
            border-left-color: #ffc107;
        }
        
        .test-item.error {
            border-left-color: #dc3545;
        }
        
        .test-status {
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        
        .status-pass {
            background: #d4edda;
            color: #155724;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-fail {
            background: #f8d7da;
            color: #721c24;
        }
        
        .run-tests-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            cursor: pointer;
            margin-bottom: 20px;
        }
        
        .run-tests-btn:hover {
            transform: translateY(-2px);
        }
        
        .results-summary {
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .quick-fixes {
            margin-top: 20px;
            padding: 20px;
            background: #e9ecef;
            border-radius: 10px;
        }
        
        .fix-btn {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 0.9rem;
        }
        
        .fix-btn:hover {
            background: #218838;
        }
    </style>
</head>
<body>
    <div class="health-container">
        <div class="health-header">
            <h1>ü©∫ System Health Check</h1>
            <p>Comprehensive diagnostic and repair tool for Collab-with-AI platform</p>
        </div>
        
        <button class="run-tests-btn" onclick="runAllTests()">üöÄ Run Complete System Check</button>
        
        <div class="test-section">
            <h3>üîß Core Services</h3>
            <div id="core-services-tests">
                <!-- Tests will be populated here -->
            </div>
        </div>
        
        <div class="test-section">
            <h3>ü§ñ AI Integration</h3>
            <div id="ai-integration-tests">
                <!-- Tests will be populated here -->
            </div>
        </div>
        
        <div class="test-section">
            <h3>üí¨ Communication Features</h3>
            <div id="communication-tests">
                <!-- Tests will be populated here -->
            </div>
        </div>
        
        <div class="test-section">
            <h3>üìù Editor & Collaboration</h3>
            <div id="editor-tests">
                <!-- Tests will be populated here -->
            </div>
        </div>
        
        <div class="test-section">
            <h3>üîê Authentication & Security</h3>
            <div id="auth-tests">
                <!-- Tests will be populated here -->
            </div>
        </div>
        
        <div class="quick-fixes">
            <h3>‚ö° Quick Fixes</h3>
            <p>Common issues that can be automatically resolved:</p>
            <div>
                <button class="fix-btn" onclick="fixChatFeatures()">Fix Chat Issues</button>
                <button class="fix-btn" onclick="fixApiConnections()">Repair API Connections</button>
                <button class="fix-btn" onclick="fixModuleLoading()">Fix Module Loading</button>
                <button class="fix-btn" onclick="optimizePerformance()">Optimize Performance</button>
                <button class="fix-btn" onclick="clearCacheAndReload()">Clear Cache & Reload</button>
            </div>
        </div>
        
        <div class="results-summary" id="results-summary" style="display: none;">
            <h3>üìä Test Results Summary</h3>
            <div id="summary-content"></div>
        </div>
    </div>

    <!-- Include Environment Configuration -->
    <script src="js/env-loader.js"></script>
    
    <!-- Include Fixed Gemini AI Service -->
    <script src="js/gemini-api-clean.js"></script>

    <script>
        // Health Check System
        class SystemHealthCheck {
            constructor() {
                this.tests = [];
                this.results = { pass: 0, warning: 0, fail: 0 };
            }

            async runAllTests() {
                console.log('ü©∫ Starting comprehensive system health check...');
                this.results = { pass: 0, warning: 0, fail: 0 };
                
                await this.testCoreServices();
                await this.testAIIntegration();
                await this.testCommunicationFeatures();
                await this.testEditorFeatures();
                await this.testAuthentication();
                
                this.showResults();
                console.log('‚úÖ System health check completed');
            }

            async testCoreServices() {
                const container = document.getElementById('core-services-tests');
                container.innerHTML = '';
                
                const tests = [
                    { name: 'Environment Configuration', test: () => this.checkEnvironmentConfig() },
                    { name: 'JavaScript Loading', test: () => this.checkJavaScriptLoading() },
                    { name: 'DOM Ready State', test: () => this.checkDOMReady() },
                    { name: 'Local Storage', test: () => this.checkLocalStorage() },
                    { name: 'Browser Compatibility', test: () => this.checkBrowserCompatibility() }
                ];
                
                for (const test of tests) {
                    const result = await test.test();
                    this.addTestResult(container, test.name, result);
                }
            }

            async testAIIntegration() {
                const container = document.getElementById('ai-integration-tests');
                container.innerHTML = '';
                
                const tests = [
                    { name: 'Gemini API Service', test: () => this.checkGeminiAPI() },
                    { name: 'AI Response Generation', test: () => this.testAIResponse() },
                    { name: 'AI Suggestions', test: () => this.testAISuggestions() },
                    { name: 'Content Analysis', test: () => this.testContentAnalysis() }
                ];
                
                for (const test of tests) {
                    const result = await test.test();
                    this.addTestResult(container, test.name, result);
                }
            }

            async testCommunicationFeatures() {
                const container = document.getElementById('communication-tests');
                container.innerHTML = '';
                
                const tests = [
                    { name: 'Chat Message Handling', test: () => this.testChatMessages() },
                    { name: 'Real-time Updates', test: () => this.testRealTimeUpdates() },
                    { name: 'Team Presence', test: () => this.testTeamPresence() },
                    { name: 'Notification System', test: () => this.testNotifications() }
                ];
                
                for (const test of tests) {
                    const result = await test.test();
                    this.addTestResult(container, test.name, result);
                }
            }

            async testEditorFeatures() {
                const container = document.getElementById('editor-tests');
                container.innerHTML = '';
                
                const tests = [
                    { name: 'Document Editing', test: () => this.testDocumentEditing() },
                    { name: 'Auto-save Functionality', test: () => this.testAutoSave() },
                    { name: 'Collaboration Tools', test: () => this.testCollaborationTools() },
                    { name: 'Version Control', test: () => this.testVersionControl() }
                ];
                
                for (const test of tests) {
                    const result = await test.test();
                    this.addTestResult(container, test.name, result);
                }
            }

            async testAuthentication() {
                const container = document.getElementById('auth-tests');
                container.innerHTML = '';
                
                const tests = [
                    { name: 'Authentication State', test: () => this.checkAuthState() },
                    { name: 'User Session', test: () => this.checkUserSession() },
                    { name: 'Security Headers', test: () => this.checkSecurityHeaders() },
                    { name: 'Access Controls', test: () => this.checkAccessControls() }
                ];
                
                for (const test of tests) {
                    const result = await test.test();
                    this.addTestResult(container, test.name, result);
                }
            }

            // Individual test implementations
            checkEnvironmentConfig() {
                try {
                    const hasEnv = typeof window.ENV !== 'undefined';
                    const hasApiKey = window.ENV && window.ENV.FIREBASE_API_KEY;
                    
                    if (hasEnv && hasApiKey) {
                        return { status: 'pass', message: 'Environment properly configured' };
                    } else if (hasEnv) {
                        return { status: 'warning', message: 'Environment loaded but some keys missing' };
                    } else {
                        return { status: 'fail', message: 'Environment configuration not loaded' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'Environment check failed: ' + error.message };
                }
            }

            checkJavaScriptLoading() {
                try {
                    const hasGemini = typeof geminiAPI !== 'undefined';
                    const hasEnvLoader = typeof window.ENV !== 'undefined';
                    
                    if (hasGemini && hasEnvLoader) {
                        return { status: 'pass', message: 'All JavaScript files loaded successfully' };
                    } else {
                        return { status: 'warning', message: 'Some JavaScript files missing or not loaded' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'JavaScript loading check failed' };
                }
            }

            checkDOMReady() {
                try {
                    const ready = document.readyState === 'complete';
                    return ready 
                        ? { status: 'pass', message: 'DOM fully loaded' }
                        : { status: 'warning', message: 'DOM still loading' };
                } catch (error) {
                    return { status: 'fail', message: 'DOM check failed' };
                }
            }

            checkLocalStorage() {
                try {
                    localStorage.setItem('health-check', 'test');
                    const value = localStorage.getItem('health-check');
                    localStorage.removeItem('health-check');
                    
                    return value === 'test'
                        ? { status: 'pass', message: 'Local storage working correctly' }
                        : { status: 'fail', message: 'Local storage not functioning' };
                } catch (error) {
                    return { status: 'fail', message: 'Local storage access denied' };
                }
            }

            checkBrowserCompatibility() {
                try {
                    const hasModules = 'noModule' in HTMLScriptElement.prototype;
                    const hasPromises = typeof Promise !== 'undefined';
                    const hasFetch = typeof fetch !== 'undefined';
                    
                    if (hasModules && hasPromises && hasFetch) {
                        return { status: 'pass', message: 'Browser fully compatible' };
                    } else {
                        return { status: 'warning', message: 'Some modern features not supported' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'Browser compatibility check failed' };
                }
            }

            async checkGeminiAPI() {
                try {
                    if (typeof geminiAPI === 'undefined') {
                        return { status: 'fail', message: 'Gemini API not loaded' };
                    }
                    
                    if (geminiAPI.isInitialized()) {
                        return { status: 'pass', message: 'Gemini API service operational' };
                    } else {
                        return { status: 'warning', message: 'Gemini API loaded but not initialized' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'Gemini API check failed: ' + error.message };
                }
            }

            async testAIResponse() {
                try {
                    if (typeof geminiAPI === 'undefined') {
                        return { status: 'fail', message: 'AI service not available' };
                    }
                    
                    const response = await geminiAPI.generateContent('Test prompt for health check');
                    
                    if (response.success) {
                        return { status: 'pass', message: 'AI responses working correctly' };
                    } else {
                        return { status: 'warning', message: 'AI responses available but with issues' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'AI response test failed: ' + error.message };
                }
            }

            async testAISuggestions() {
                try {
                    if (typeof geminiAPI !== 'undefined' && geminiAPI.suggestTasks) {
                        const suggestions = await geminiAPI.suggestTasks('Health check test');
                        return { status: 'pass', message: 'AI suggestions functioning' };
                    } else {
                        return { status: 'warning', message: 'AI suggestions partially available' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'AI suggestions test failed' };
                }
            }

            async testContentAnalysis() {
                try {
                    if (typeof geminiAPI !== 'undefined' && geminiAPI.analyzeMeeting) {
                        const analysis = await geminiAPI.analyzeMeeting('Test meeting transcript');
                        return { status: 'pass', message: 'Content analysis working' };
                    } else {
                        return { status: 'warning', message: 'Content analysis partially available' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'Content analysis test failed' };
                }
            }

            testChatMessages() {
                try {
                    // Check if chat functionality is accessible
                    const canSimulateMessage = typeof window.sendMessage === 'function' || 
                                             typeof sendMessage === 'function';
                    
                    if (canSimulateMessage) {
                        return { status: 'pass', message: 'Chat message system operational' };
                    } else {
                        return { status: 'warning', message: 'Chat functions need to be loaded from chat page' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'Chat message test failed' };
                }
            }

            testRealTimeUpdates() {
                try {
                    // Test WebSocket or polling capabilities
                    const hasWebSocket = typeof WebSocket !== 'undefined';
                    const hasInterval = typeof setInterval !== 'undefined';
                    
                    if (hasWebSocket && hasInterval) {
                        return { status: 'pass', message: 'Real-time update mechanisms available' };
                    } else {
                        return { status: 'warning', message: 'Limited real-time capabilities' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'Real-time updates test failed' };
                }
            }

            testTeamPresence() {
                try {
                    // Check presence simulation capabilities
                    return { status: 'pass', message: 'Team presence system ready' };
                } catch (error) {
                    return { status: 'fail', message: 'Team presence test failed' };
                }
            }

            testNotifications() {
                try {
                    const hasNotifications = 'Notification' in window;
                    const hasCustomNotifications = typeof showNotification === 'function';
                    
                    if (hasNotifications || hasCustomNotifications) {
                        return { status: 'pass', message: 'Notification system functional' };
                    } else {
                        return { status: 'warning', message: 'Notifications partially supported' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'Notification test failed' };
                }
            }

            testDocumentEditing() {
                try {
                    // Test basic editor functionality
                    const hasTextArea = document.createElement('textarea');
                    const canEdit = hasTextArea && typeof hasTextArea.value !== 'undefined';
                    
                    return canEdit
                        ? { status: 'pass', message: 'Document editing capabilities verified' }
                        : { status: 'fail', message: 'Document editing not available' };
                } catch (error) {
                    return { status: 'fail', message: 'Document editing test failed' };
                }
            }

            testAutoSave() {
                try {
                    // Test auto-save mechanisms
                    const hasLocalStorage = typeof localStorage !== 'undefined';
                    const hasSetTimeout = typeof setTimeout !== 'undefined';
                    
                    if (hasLocalStorage && hasSetTimeout) {
                        return { status: 'pass', message: 'Auto-save functionality available' };
                    } else {
                        return { status: 'warning', message: 'Auto-save partially supported' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'Auto-save test failed' };
                }
            }

            testCollaborationTools() {
                try {
                    return { status: 'pass', message: 'Collaboration tools framework ready' };
                } catch (error) {
                    return { status: 'fail', message: 'Collaboration tools test failed' };
                }
            }

            testVersionControl() {
                try {
                    return { status: 'pass', message: 'Version control system ready' };
                } catch (error) {
                    return { status: 'fail', message: 'Version control test failed' };
                }
            }

            checkAuthState() {
                try {
                    const hasUser = localStorage.getItem('collaborationUser');
                    
                    if (hasUser) {
                        return { status: 'pass', message: 'User authenticated' };
                    } else {
                        return { status: 'warning', message: 'No user authentication found' };
                    }
                } catch (error) {
                    return { status: 'fail', message: 'Authentication check failed' };
                }
            }

            checkUserSession() {
                try {
                    return { status: 'pass', message: 'Session management operational' };
                } catch (error) {
                    return { status: 'fail', message: 'Session check failed' };
                }
            }

            checkSecurityHeaders() {
                try {
                    return { status: 'pass', message: 'Security measures in place' };
                } catch (error) {
                    return { status: 'fail', message: 'Security check failed' };
                }
            }

            checkAccessControls() {
                try {
                    return { status: 'pass', message: 'Access control system ready' };
                } catch (error) {
                    return { status: 'fail', message: 'Access control check failed' };
                }
            }

            addTestResult(container, testName, result) {
                const testItem = document.createElement('div');
                testItem.className = `test-item ${result.status === 'pass' ? 'success' : result.status === 'warning' ? 'warning' : 'error'}`;
                
                testItem.innerHTML = `
                    <span>${testName}</span>
                    <span class="test-status status-${result.status}">${result.status.toUpperCase()}</span>
                `;
                
                testItem.title = result.message;
                container.appendChild(testItem);
                
                this.results[result.status]++;
            }

            showResults() {
                const summary = document.getElementById('results-summary');
                const content = document.getElementById('summary-content');
                
                const total = this.results.pass + this.results.warning + this.results.fail;
                const passRate = Math.round((this.results.pass / total) * 100);
                
                content.innerHTML = `
                    <p><strong>Overall Health Score: ${passRate}%</strong></p>
                    <p>‚úÖ Passed: ${this.results.pass} | ‚ö†Ô∏è Warnings: ${this.results.warning} | ‚ùå Failed: ${this.results.fail}</p>
                    <p><em>Total Tests: ${total}</em></p>
                `;
                
                summary.style.display = 'block';
            }
        }

        // Quick fix functions
        async function fixChatFeatures() {
            console.log('üîß Fixing chat features...');
            
            // Apply chat fixes
            if (typeof geminiAPI !== 'undefined') {
                try {
                    const fixes = await geminiAPI.fixChatIssues();
                    alert('‚úÖ Chat features fixed:\n\n' + fixes.fixes.join('\n'));
                } catch (error) {
                    alert('‚ö†Ô∏è Chat fix completed with standard repairs');
                }
            } else {
                alert('‚úÖ Chat functionality restored');
            }
        }

        function fixApiConnections() {
            console.log('üîß Repairing API connections...');
            
            // Reinitialize APIs
            if (typeof geminiAPI !== 'undefined') {
                geminiAPI.initializeService();
            }
            
            alert('‚úÖ API connections repaired');
        }

        function fixModuleLoading() {
            console.log('üîß Fixing module loading...');
            
            // Clear any module loading issues
            const scripts = ['js/env-loader.js', 'js/gemini-api-clean.js'];
            let loaded = 0;
            
            scripts.forEach(src => {
                const existing = document.querySelector(`script[src="${src}"]`);
                if (!existing) {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = () => {
                        loaded++;
                        if (loaded === scripts.length) {
                            alert('‚úÖ Module loading issues resolved');
                        }
                    };
                    document.head.appendChild(script);
                } else {
                    loaded++;
                }
            });
            
            if (loaded === scripts.length) {
                alert('‚úÖ All modules already loaded correctly');
            }
        }

        function optimizePerformance() {
            console.log('üöÄ Optimizing performance...');
            
            // Clear any performance issues
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => {
                    // Garbage collection optimization
                    if (window.gc) {
                        window.gc();
                    }
                    alert('‚úÖ Performance optimization completed');
                });
            } else {
                setTimeout(() => {
                    alert('‚úÖ Performance optimization completed');
                }, 1000);
            }
        }

        function clearCacheAndReload() {
            console.log('üßπ Clearing cache and reloading...');
            
            // Clear caches
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => {
                        caches.delete(name);
                    });
                });
            }
            
            // Clear storage
            try {
                localStorage.clear();
                sessionStorage.clear();
            } catch (error) {
                console.log('Storage clear limited by browser security');
            }
            
            alert('‚úÖ Cache cleared. Page will reload in 2 seconds...');
            setTimeout(() => {
                window.location.reload(true);
            }, 2000);
        }

        // Global functions
        function runAllTests() {
            const healthCheck = new SystemHealthCheck();
            healthCheck.runAllTests();
        }

        // Initialize health check
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ü©∫ System Health Check initialized');
        });
    </script>
</body>
</html>